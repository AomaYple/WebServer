2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #pragma once

#include "Buffer.h"

#include <string>
#include <source_location>

class Client {
public:
    Client(int fileDescriptor, std::string information);

    Client(const Client &client) = delete;

    Client(Client &&client) noexcept;

    auto operator=(Client &&client) noexcept -> Client &;

    [[nodiscard]] auto send(std::source_location sourceLocation = std::source_location::current()) -> uint32_t;

    [[nodiscard]] auto receive(std::source_location sourceLocation = std::source_location::current()) -> uint32_t;

    auto write(const std::string_view &data) -> void;

    [[nodiscard]] auto read() -> std::string;

    [[nodiscard]] auto get() const -> int;

    [[nodiscard]] auto getExpire() const -> unsigned int;

    auto setExpire(unsigned int time) -> void;

    ~Client();
private:
    int self;
    unsigned int timeout;
    std::string information;
    Buffer sendBuffer, receiveBuffer;
};


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #pragma once

#include <queue>
#include <thread>
#include <source_location>

enum class Level {
    INFO,
    WARN,
    ERROR
};

class Log {
public:
    static auto add(const std::source_location &sourceLocation, const Level &level, const std::string_view &data) -> void;

    static auto stopWork() -> void;
private:
    std::queue<std::tuple<std::chrono::system_clock::time_point, std::thread::id, std::source_location, Level, std::string>>
            inputLog, outputLog;
    bool stop {false};
    std::mutex lock;
    std::atomic_flag notice;
    std::jthread work;

    static Log log;

    Log();

    auto addLog(const std::source_location &sourceLocation, const Level &level, const std::string_view &data) -> void;

    auto stopWorkLog() -> void;
};


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #include "Client.h"
#include "Log.h"

#include <cstring>

#include <sys/socket.h>
#include <sys/epoll.h>

using std::string, std::string_view, std::to_string, std::source_location;

Client::Client(int fileDescriptor, std::string information) : self(fileDescriptor), timeout(0), information(std::move(information)) {}

Client::Client(Client &&client) noexcept : self(client.self), timeout(0), information(std::move(client.information)),
        sendBuffer(std::move(client.sendBuffer)), receiveBuffer(std::move(client.receiveBuffer)) {
    client.self = -1;
    client.timeout = 0;
}

auto Client::operator=(Client &&client) noexcept -> Client & {
    if (this != &client) {
        this->self = client.self;
        this->timeout = client.timeout;
        this->information = std::move(client.information);
        this->sendBuffer = std::move(client.sendBuffer);
        this->receiveBuffer = std::move(client.receiveBuffer);
        client.self = -1;
        client.timeout = 0;
    }
    return *this;
}

auto Client::send(std::source_location sourceLocation) -> uint32_t {
    uint32_t event {this->timeout == 0 ? 0 : EPOLLET | EPOLLRDHUP | EPOLLIN};

    string_view data {this->sendBuffer.read()};
    ssize_t allSentBytes {0};

    while (allSentBytes < data.size()) {
        ssize_t sentBytes {::write(this->self, data.data() + allSentBytes, data.size() - allSentBytes)};
        if (sentBytes > 0)
            allSentBytes += sentBytes;
        else if (sentBytes == 0) {
            event = 0;
            break;
        } else {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                event = EPOLLET | EPOLLOUT;
                Log::add(sourceLocation, Level::WARN, " too much data can not be sent to " + this->information);
            } else {
                event = 0;
                Log::add(sourceLocation, Level::ERROR, this->information + " send error: " + strerror(errno));
            }

            break;
        }
    }

    if (allSentBytes > 0)
        this->sendBuffer.adjustRead(allSentBytes);

    return event;
}

auto Client::receive(std::source_location sourceLocation) -> uint32_t {
    uint32_t event {EPOLLET | EPOLLOUT};

    ssize_t allReceivedBytes {0};

    while (true) {
        auto data {this->receiveBuffer.writableData()};
        ssize_t receivedBytes {::read(this->self, data.first, data.second)};
        if (receivedBytes > 0) {
            allReceivedBytes += receivedBytes;
            this->receiveBuffer.adjustWrite(receivedBytes);
        } else if (receivedBytes == 0) {
            event = 0;
            break;
        } else {
            if (errno != EAGAIN && errno != EWOULDBLOCK) {
                event = 0;
                Log::add(sourceLocation, Level::ERROR, this->information + " receive error: " + strerror(errno));
            }

            break;
        }
    }

    return event;
}

auto Client::write(const std::string_view &data) -> void {
    this->sendBuffer.write(data);
}

auto Client::read() -> string {
    string data {this->receiveBuffer.read()};
    this->receiveBuffer.adjustRead(data.size());

    return data;
}

auto Client::get() const -> int {
    return this->self;
}

auto Client::getExpire() const -> unsigned int {
    return this->timeout;
}

auto Client::setExpire(unsigned int time) -> void {
    this->timeout = time;
}

Client::~Client() {
    if (this->self != -1) {
        if (shutdown(this->self, SHUT_RDWR) == -1)
            Log::add(source_location::current(), Level::ERROR, this->information + " shutdown error: " + strerror(errno));

        if (close(this->self) == -1)
            Log::add(source_location::current(), Level::ERROR, this->information + " close error: " + strerror(errno));
    }
}


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #include "Buffer.h"

using std::string_view, std::pair;

Buffer::Buffer(unsigned int size) : self(size), start(0), end(0) {}

Buffer::Buffer(Buffer &&buffer) noexcept : self(std::move(buffer.self)), start(buffer.start), end(buffer.end) {
    buffer.start = buffer.end = 0;
}

auto Buffer::operator=(Buffer &&buffer) noexcept -> Buffer & {
    if (this != &buffer) {
        this->self = std::move(buffer.self);
        this->start = buffer.start;
        this->end = buffer.end;
        buffer.start = buffer.end = 0;
    }
    return *this;
}

auto Buffer::write(const string_view &data) -> void {
    if (data.size() > this->self.size() - this->end && this->start > 0) {
        std::copy(this->self.begin() + this->start, this->self.begin() + this->end, this->self.begin());
        this->end -= this->start;
        this->start = 0;
    }

    if (data.size() > this->self.size() - this->end)
        this->self.resize((data.size() + this->end - this->start) * 2);

    std::copy(data.begin(), data.end(), this->self.begin() + this->end);
    this->end += data.size();
}

auto Buffer::read() -> string_view {
    return {this->self.begin() + this->start, this->self.begin() + this->end};
}

auto Buffer::writableData() -> pair<char *, unsigned int> {
    return {this->self.data() + this->end, this->self.size() - this->end};
}

auto Buffer::adjustWrite(unsigned int size) -> void {
    this->end += size;

    if (this->end == this->self.size() && this->start > 0) {
        std::copy(this->self.begin() + this->start, this->self.begin() + this->end, this->self.begin());
        this->end -= this->start;
        this->start = 0;
    }

    if (this->end == this->self.size())
        this->self.resize(this->self.size() * 2);
}

auto Buffer::adjustRead(unsigned int size) -> void {
    this->start += size;

    if (this->start == this->end)
        this->start = this->end = 0;
}

auto Buffer::empty() const -> bool {
    return this->start == this->end;
}


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #include "Timer.h"
#include "Log.h"

#include <cstring>

#include <sys/timerfd.h>

using std::string, std::unordered_map, std::shared_ptr, std::source_location;

Timer::Timer(source_location sourceLocation) : self(timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK)), now(0) {
    if (this->self == -1)
        Log::add(sourceLocation, Level::ERROR, "Timer create error: " + string(strerror(errno)));

    itimerspec time { {1, 0}, {1, 0}};
    if (timerfd_settime(this->self, 0, &time, nullptr) == -1)
        Log::add(sourceLocation, Level::ERROR, "Timer setTime error: " + string(strerror(errno)));
}

Timer::Timer(Timer &&timer) noexcept : self(timer.self), now(timer.now) {
    timer.self = -1;
    timer.now = 0;
}

auto Timer::operator=(Timer &&timer) noexcept -> Timer & {
    if (this != &timer) {
        this->self = timer.self;
        this->now = timer.now;
        timer.self = -1;
        timer.now = 0;
    }
    return *this;
}

auto Timer::add(const shared_ptr<Client>& client) -> void {
    unsigned int location {this->now + client->getExpire()};
    if (location > this->wheel.size() - 1)
        location -= this->wheel.size();

    this->wheel.at(location).emplace_back(client);
    this->table.emplace(client->get(), location);
}

auto Timer::reset(shared_ptr<Client> &client) -> void {
    this->remove(client);
    this->add(client);
}

auto Timer::remove(shared_ptr<Client> &client) -> void {
    this->wheel[this->table.at(client->get())].remove(client);
    this->table.erase(client->get());
}

auto Timer::handleRead(unordered_map<int, shared_ptr<Client>> &clients, source_location sourceLocation) -> void {
    uint64_t number {0};
    if (read(this->self, &number, sizeof(number)) == sizeof(number)) {
        while (number > 0) {
            auto &list {this->wheel[this->now++]};

            while (!list.empty()) {
                int fileDescriptor {list.back()->get()};
                list.pop_back();
                this->table.erase(fileDescriptor);
                clients.erase(fileDescriptor);
            }

            --number;
        }
    } else
        Log::add(sourceLocation, Level::ERROR, "Timer read error: " + string(strerror(errno)));
}

auto Timer::get() const -> int {
    return this->self;
}

Timer::~Timer() {
    if (this->self != -1 && close(this->self) == -1)
        Log::add(source_location::current(), Level::ERROR, "Timer close error: " + string(strerror(errno)));
}


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #include "Log.h"

#include <fstream>
#include <iomanip>

using std::string_view, std::ofstream, std::ios, std::get, std::put_time, std::this_thread::get_id, std::mutex, std::lock_guard,
    std::atomic_ref, std::chrono::system_clock, std::source_location;

Log Log::log;

auto Log::add(const source_location &sourceLocation, const Level &level, const string_view &data) -> void {
    log.addLog(sourceLocation, level, data);
}

auto Log::stopWork() -> void {
    log.stopWorkLog();
}

Log::Log() : work([this] {
    ofstream file {"log.log", ios::trunc};

    while (!this->stop) {
        this->notice.wait(false);
        this->notice.clear();

        {
            lock_guard<mutex> lockGuard {this->lock};
            this->outputLog.swap(this->inputLog);
        }

        while (!this->outputLog.empty()) {
            auto &log {this->outputLog.front()};

            time_t now {system_clock::to_time_t(get<0>(log))};
            file << put_time(localtime(&now), "%F %T ");

            file << get<1>(log) << " ";

            source_location &sourceLocation {get<2>(log)};
            file << sourceLocation.file_name() << ":" << sourceLocation.line() << ":" << sourceLocation.function_name() << " ";

            switch (get<3>(log)) {
                case Level::INFO:
                    file << "INFO ";
                    break;
                case Level::WARN:
                    file << "WARN ";
                    break;
                case Level::ERROR:
                    file << "ERROR ";
                    break;
            }

            file << get<4>(log) << "\n";

            this->outputLog.pop();
        }
    }

    file.close();
}) {}

auto Log::addLog(const source_location &sourceLocation, const Level &level, const string_view &data) -> void {
    if (!this->stop) {
        {
            lock_guard<mutex> lockGuard {this->lock};
            this->inputLog.emplace(system_clock::now(), get_id(), sourceLocation, level, data);
        }

        this->notice.test_and_set();
        this->notice.notify_one();
    }
}

auto Log::stopWorkLog() -> void {
    atomic_ref<bool> atomicStop {this->stop};
    atomicStop = true;
}


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #include "Server.h"
#include "Log.h"

#include <cstring>

#include <fcntl.h>

using std::string, std::string_view, std::to_string, std::vector, std::shared_ptr, std::make_shared, std::source_location;

Server::Server(unsigned short port, std::source_location sourceLocation) : self(socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0)),
                                                                           idleFileDescriptor(open("/dev/null", O_RDONLY)), address({}), addressLength(sizeof(address)) {
    if (this->self == -1)
        Log::add(sourceLocation, Level::ERROR, "Server create error: " + string(strerror(errno)));

    int option {1};
    if (setsockopt(this->self, SOL_SOCKET, SO_REUSEADDR, &option, sizeof(option)) == -1)
        Log::add(sourceLocation, Level::ERROR, "Server reuseAddress error: " + string(strerror(errno)));

    if (setsockopt(this->self, SOL_SOCKET, SO_REUSEPORT, &option, sizeof(option)) == -1)
        Log::add(sourceLocation, Level::ERROR, "Server reusePort error: " + string(strerror(errno)));

    this->address.sin_family = AF_INET;
    this->address.sin_port = htons(port);

    if (inet_pton(AF_INET, "127.0.0.1", &this->address.sin_addr) != 1)
        Log::add(sourceLocation, Level::ERROR, "Server translate ipAddress error: " + string(strerror(errno)));

    if (::bind(this->self, reinterpret_cast<sockaddr *>(&this->address), this->addressLength) == -1)
        Log::add(sourceLocation, Level::ERROR, "Server bind error: " + string(strerror(errno)));

    if (::listen(this->self, SOMAXCONN) == -1)
        Log::add(sourceLocation, Level::ERROR, "Server listen error: " + string(strerror(errno)));
}

Server::Server(Server &&server) noexcept : self(server.self), idleFileDescriptor(server.idleFileDescriptor), address(server.address),
                                           addressLength(server.addressLength) {
    server.self = -1;
    server.idleFileDescriptor = -1;
    server.address = {};
    server.addressLength = 0;
}

auto Server::operator=(Server &&server) noexcept -> Server & {
    if (this != &server) {
        this->self = server.self;
        this->idleFileDescriptor = server.idleFileDescriptor;
        this->address = server.address;
        this->addressLength = server.addressLength;
        server.self = -1;
        server.idleFileDescriptor = -1;
        server.address = {};
        server.addressLength = 0;
    }
    return *this;
}

auto Server::accept(source_location sourceLocation) -> vector<shared_ptr<Client>> {
    vector<shared_ptr<Client>> clients;

    while (true) {
        this->address = {};
        this->addressLength = {sizeof(this->address)};
        int fileDescriptor {accept4(this->self, reinterpret_cast<sockaddr *>(&this->address), &this->addressLength,
                                    SOCK_NONBLOCK)};

        if (fileDescriptor != -1) {
            string information(INET_ADDRSTRLEN, 0);

            if (inet_ntop(AF_INET, &this->address.sin_addr, information.data(), information.size()) == nullptr)
                Log::add(sourceLocation,Level::ERROR, "Client translate ipAddress error: " + string(strerror(errno)));

            information += ":" + to_string(ntohs(this->address.sin_port));

            Log::add(sourceLocation, Level::INFO, "new client " + information);

            clients.emplace_back(make_shared<Client>(fileDescriptor, information));
        } else {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
                break;
            else if (errno == EMFILE) {
                close(this->idleFileDescriptor);
                this->idleFileDescriptor = ::accept(this->self, nullptr, nullptr);
                close(this->idleFileDescriptor);
                this->idleFileDescriptor = open("/dev/null", O_RDONLY);
            } else {
                Log::add(sourceLocation, Level::ERROR, "Server accept error: " + string(strerror(errno)));
                break;
            }
        }
    }

    return clients;
}

auto Server::get() const -> int {
    return this->self;
}

Server::~Server() {
    if (this->self != -1 && close(this->self) == -1)
        Log::add(source_location::current(), Level::ERROR, "Server close error: " + string(strerror(errno)));
}


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #pragma once

#include "Client.h"

#include <memory>

#include <arpa/inet.h>

class Server {
public:
    explicit Server(unsigned short port, std::source_location sourceLocation = std::source_location::current());

    Server(const Server &server) = delete;

    Server(Server &&server) noexcept;

    auto operator=(Server &&server) noexcept -> Server &;

    [[nodiscard]] auto accept(std::source_location sourceLocation = std::source_location::current()) -> std::vector<std::shared_ptr<Client>>;

    [[nodiscard]] auto get() const -> int;

    ~Server();
private:
    int self, idleFileDescriptor;
    sockaddr_in address;
    socklen_t addressLength;
};


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #pragma once

#include <vector>
#include <string_view>

class Buffer {
public:
    explicit Buffer(unsigned int size = 1024);

    Buffer(const Buffer &buffer) = default;

    Buffer(Buffer &&buffer) noexcept;

    auto operator=(Buffer &&buffer) noexcept -> Buffer &;

    auto write(const std::string_view &data) -> void;

    auto read() -> std::string_view;

    auto writableData() -> std::pair<char *, unsigned int>;

    auto adjustWrite(unsigned int size) -> void;

    auto adjustRead(unsigned int size) -> void;

    [[nodiscard]] auto empty() const -> bool;
private:
    std::vector<char> self;
    unsigned int start, end;
};


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #pragma once

#include <string>
#include <unordered_map>

class Http {
public:
    static auto analysis(const std::string &request) -> std::pair<std::string, bool>;
private:
    std::unordered_map<std::string, std::string> webpages;

    static Http http;

    Http();
};


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #pragma once

#include "Client.h"

#include <array>
#include <list>
#include <unordered_map>
#include <memory>

class Timer {
public:
    explicit Timer(std::source_location sourceLocation = std::source_location::current());

    Timer(const Timer &timer) = delete;

    Timer(Timer &&timer) noexcept;

    auto operator=(Timer &&timer) noexcept -> Timer &;

    auto add(const std::shared_ptr<Client>& client) -> void;

    auto reset(std::shared_ptr<Client> &client) -> void;

    auto remove(std::shared_ptr<Client> &client) -> void;

    auto handleRead(std::unordered_map<int, std::shared_ptr<Client>> &clients, std::source_location sourceLocation = std::source_location::current()) -> void;

    auto get() const -> int;

    ~Timer();
private:
    int self;
    unsigned int now;
    std::array<std::list<std::shared_ptr<Client>>, 3600> wheel;
    std::unordered_map<int ,unsigned int> table;
};


2023-04-08 18:26:59 140680391373888 /home/aomayple/Projects/C++/WebServer/main.cpp:16:int main() INFO #include "Http.h"
#include "Log.h"

#include <fstream>
#include <filesystem>
#include <regex>

using std::string, std::to_string, std::pair, std::ifstream, std::stringstream, std::filesystem::directory_iterator,
    std::regex, std::smatch, std::regex_search;

Http Http::http;

auto Http::analysis(const string &request) -> pair<string, bool> {
    pair<string, bool> response;
    smatch result;

    string protocol, statusCode, connection, content;

    if (regex_search(request, result, regex("HTTP/(.+)"))) {
        if (result.str(1) == "1.1") {
            protocol = "HTTP/1.1 ";
            connection = "Connection: keep-alive\n";
            response.second = true;
        } else if (result.str(1) == "1.0") {
            protocol = "HTTP/1.0 ";
            connection = "Connection: close\n";
            response.second = false;
        } else
            return {"HTTP/1.0 505 HTTP Version Not Supported\n"
                    "Content-Length: 0\n\n", false};
    } else
        return {"HTTP/1.0 500 Internal Server Error\n"
                "Content-Length: 0\n\n", false};

    if (regex_search(request, result, regex("Connection: (.+)"))) {
        if (result.str(1) == "keep-alive") {
            connection = "Connection: keep-alive\n";
            response.second = true;
        } else if (result.str(1) == "close") {
            connection = "Connection: close\n";
            response.second = false;
        }
    }

    if (regex_search(request, result, regex("GET /(.*) "))) {
        auto findResult {http.webpages.find(result.str(1))};
        if (findResult != http.webpages.end()) {
            statusCode = "200 OK\n";
            content = findResult->second;
        }
        else
            return {"HTTP/1.0 404 Not Found\n"
                    "Content-Length: 0\n\n", false};
    } else
        return {"HTTP/1.0 500 Internal Server Error\n"
                "Content-Length: 0\n\n", false};

    response.first = protocol + statusCode + connection + content;

    return response;
}

Http::Http() {
    this->webpages.emplace("", "Content-Length: 0\n\n");

    for (auto &filePath : directory_iterator("web")) {
        ifstream file {filePath.path().string()};
        stringstream stream;

        stream << file.rdbuf();

        this->webpages.emplace(filePath.path().string(), "Content-Length: " + to_string(stream.str().size()) + "\n\n" + stream.str());

        file.close();
    }
}

